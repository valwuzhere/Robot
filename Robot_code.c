#pragma config(Sensor, in1,    InfraCollector1, sensorReflection)
#pragma config(Sensor, in2,    InfraCollector2, sensorReflection)
#pragma config(Sensor, dgtl1,  RedLED1,        sensorDigitalOut)
#pragma config(Sensor, dgtl2,  RedLED2,        sensorDigitalOut)
#pragma config(Sensor, dgtl6,  Sonic,          sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  limitright,     sensorTouch)
#pragma config(Sensor, dgtl9,  limitleft,      sensorTouch)
#pragma config(Sensor, dgtl10, RedLED3,        sensorDigitalOut)
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           Arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motor2,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int beacon_threshold =477;
const   int OFF = 0;
const   int ON  = 1;
int difference;
int difference_2;

/* Purpose: to find the differnce of values that the IR sensor reads
        This is the difference of the readings of the first phototransistor

Returns: the difference of values 
*/

int monitorLight1()
{
        static int minLevelIR1 = 3230;
        static int maxLevelIR1 = 0;
        static int diffLevelIR1 = 0;

        int lightLevel1 = SensorValue[InfraCollector1];

        if ( time1[T1] > 100 )  {
                diffLevelIR1 = maxLevelIR1 - minLevelIR1;
                maxLevelIR1 = 0;
                minLevelIR1 = 3230;
                clearTimer(T1);
         } else {
                if ( lightLevel1 < minLevelIR1 ) {
                        minLevelIR1 = lightLevel1;
                        } else if ( lightLevel1 > maxLevelIR1 ) {
                        maxLevelIR1 = lightLevel1;
                }
        }

        return(diffLevelIR1);
}

/* Purpose: to find the differnce of values that the IR sensor reads
        This is the difference of the readings of the second phototransistor

Returns: the difference of values 
*/

int monitorLight2()
{

        static int minLevelIR2 = 4025;
        static int maxLevelIR2 = 0;
        static int diffLevelIR2 = 0;

        int lightLevel2 = SensorValue[InfraCollector2];


        if ( time1[T1] > 100 )  {
                diffLevelIR2 = maxLevelIR2 - minLevelIR2;
                maxLevelIR2 = 0;
                minLevelIR2 = 4025;
                clearTimer(T1);
        } else {
                if ( lightLevel2 < minLevelIR2 ) {
                        minLevelIR2 = lightLevel2;
                        } else if ( lightLevel2 > maxLevelIR2 ) {
                        maxLevelIR2 = lightLevel2;
                }
        }
        return(diffLevelIR2);
}

/* Purpose: to identify in which state we are in 

States : 1. Nothing detected: the phototransistor has not detected a big difference of the values,
        meaning that the value obtaned by the functions monitorLight2() and monitorLight1() are 
        smaller than the constant beacon_threshold

        2. somethingDetected: the phototransistor is changing values by a lot, meaning that the difffernece is high.
        the values obtained by the function monitorLight2() and monitorLight1() are 
        grater than the constant beacon_threshold

        3. armDown: once somthing was detected and the differnce hasn't 
        changes then the arm will go down

        4. we_Done: arm is down and the robot has backed up. 
        We signal complition with an LED.

        5. limits: if a limit switch sensor reads a value the robot will change to this state and 
        will back up and go back to state 1


        */

enum T_system_state
{
  nothingDetected = 0,
  somethingDetected,
  armDown,
  we_Done,
  limits
};

/* Purpose: set the LEDs off 
 */

void init_light_status()
{

  SensorValue(RedLED1)= OFF;
  SensorValue(RedLED2)= OFF;
  SensorValue(RedLED3)= OFF;

}


task main()
{

  T_system_state system_state;
  init_light_status();

  system_state  = nothingDetected;

  // infinite loop
  while (true) {

    switch(system_state){

        case(nothingDetected):


                SensorValue(RedLED1) = OFF;
                SensorValue(RedLED2)= OFF;
                difference = monitorLight1();
                difference_2=monitorLight2();

                if(SensorValue(limitright)==1 || SensorValue(limitleft)==1){
                	system_state = limits;
                }

                if (difference>beacon_threshold && difference_2<beacon_threshold){
                        motor[motor1]=-25;
                        motor[motor2]=25;
                        difference = monitorLight1();
                        difference_2=monitorLight2();

  		        }else  if (difference_2>beacon_threshold && difference<beacon_threshold){
      	                motor[motor1]=25;
                        motor[motor2]=-25;

 	            }else if (difference>beacon_threshold && difference_2>beacon_threshold){
                        system_state = somethingDetected;

                }else {
 		                motor[motor1]=35;
                        motor[motor2]=-35;
                }

       break;
       // case 1.

        case(somethingDetected):

                SensorValue(RedLED1) = ON;
                SensorValue(RedLED2)= ON;
                difference = monitorLight1();
		        difference_2=monitorLight2();

                while(SensorValue(Sonic)>15){
                        motor[motor1]=35;
                        motor[motor2]=35;

                        if(SensorValue(limitright)==1 || SensorValue(limitleft)==1){
                	        system_state = limits;
                	        break;
                        }

                        difference = monitorLight1();
		                 difference_2=monitorLight2();

		                if (difference<beacon_threshold || difference_2<beacon_threshold){
                                break;
                        }
                        
                }//end of while loop

                if (difference<beacon_threshold || difference_2<beacon_threshold){
                        system_state = nothingDetected;
                }

                motor[motor1]=0;
                motor[motor2]=0;
                SensorValue(RedLED1) = OFF;
                SensorValue(RedLED2)= OFF;

                if (difference>beacon_threshold && difference_2>beacon_threshold){
                        system_state = armDown;
                }


        break;
        //case 2.


       case(armDown):

                //lower the arm
                motor[Arm] = 15;
                wait1Msec(2086);

                //stop the arm for 2 seconds
                motor[Arm] = 0;
                wait1Msec(2000);

                //bring the arm back up
                motor[Arm] = -20;
                wait1Msec(1500);

                // stop the arm and go backwards in a small angle
                motor[Arm] = 0;
                motor[motor1] = -20;
                motor[motor2] = -50;
                wait1Msec(1000);

                // stop the robot and arm down again 
                motor[motor1] = 0;
                motor[motor2] = 0;
                motor[Arm] = 15;
                wait1Msec(1000);

                // stop arm and keep going backwards
                motor[Arm] = 0;
                motor[motor1] = -30;
                motor[motor2] = -30;
                wait1Msec(1500);

                //stop 
                motor[motor1] = 0;
                motor[motor2] = 0;

                SensorValue(RedLED1) = OFF;
                SensorValue(RedLED2)= OFF;


                if (motor[motor1] == 0 && motor[motor2] == 0){
                        system_state = we_Done;
                }

       break;
       //case 3.

       case(we_Done):

                SensorValue(RedLED3)= ON;

 	break;
        // case 4.


       case (limits):

                motor[motor1]=-30;
                motor[motor2]=-30;
                wait1Msec(1000);

                system_state = nothingDetected;

       break;
       //case 4


       default:
  }
}
}
